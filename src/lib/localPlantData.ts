/**
 * LOCAL PLANT DATA LIBRARY
 *
 * This library provides access to plant data from the local plants.json file.
 * It replaces the previous API-based approach with a static JSON dataset.
 *
 * The plants.json file is the authoritative source, generated by:
 * 1. scripts/fetch-perenual.ts - Fetches data from Perenual API
 * 2. scripts/fetch-aspca-toxicity.ts - Fetches ASPCA toxicity data
 * 3. scripts/build-master-plant-list.ts - Merges all data sources
 *
 * USAGE:
 *   import { getPlants, getPlantById, filterPlants } from '@/lib/localPlantData';
 */

import { Plant, PlantFilters } from '@/types/plant';
import plantsData from '@/data/plants-full.json';

// Cast the imported JSON to Plant array
const ALL_PLANTS: Plant[] = plantsData as Plant[];

/**
 * Get all plants from local dataset
 */
export function getPlants(): Plant[] {
  return ALL_PLANTS;
}

/**
 * Get a single plant by ID
 */
export function getPlantById(id: string): Plant | null {
  const plant = ALL_PLANTS.find(p => p.id === id);
  return plant || null;
}

/**
 * Get plants suitable for a specific USDA hardiness zone
 */
export function getPlantsForZone(zone: number): Plant[] {
  return ALL_PLANTS.filter(plant => {
    if (!plant.zoneMin || !plant.zoneMax) return true;
    return zone >= plant.zoneMin && zone <= plant.zoneMax;
  });
}

/**
 * Get curated starter plants for a specific zone
 * (Plants marked as beginner-friendly and curated for the zone)
 */
export function getCuratedPlantsForZone(zone: number): Plant[] {
  return ALL_PLANTS.filter(plant =>
    plant.curatedForZones && plant.curatedForZones.includes(zone)
  );
}

/**
 * Filter plants based on multiple criteria
 */
export function filterPlants(plants: Plant[], filters: PlantFilters): Plant[] {
  return plants.filter(plant => {
    // Zone filter
    if (filters.zone !== undefined) {
      if (!plant.zoneMin || !plant.zoneMax) return true;
      if (filters.zone < plant.zoneMin || filters.zone > plant.zoneMax) return false;
    }

    // Native filter
    if (filters.nativeOnly && !plant.isNative) return false;

    // Pollinator filter
    if (filters.pollinatorFriendlyOnly && !plant.isPollinatorFriendly) return false;

    // Toxic to pets filter
    if (filters.excludeToxicToPets && plant.toxicityToPets === 'toxic') return false;

    // Sun exposure filter
    if (filters.sunExposure && filters.sunExposure.length > 0) {
      if (!plant.sunExposure || !plant.sunExposure.some(se => filters.sunExposure!.includes(se))) {
        return false;
      }
    }

    // Plant type filter
    if (filters.plantType && filters.plantType.length > 0) {
      if (!plant.plantType || !filters.plantType.includes(plant.plantType)) {
        return false;
      }
    }

    // Water needs filter
    if (filters.waterNeeds && plant.waterNeeds !== filters.waterNeeds) {
      return false;
    }

    // Beginner friendly filter
    if (filters.beginnerFriendlyOnly && !plant.beginnerFriendly) return false;

    return true;
  });
}

/**
 * Get all plants with optional filters applied
 */
export function getAllPlants(filters?: PlantFilters): Plant[] {
  const plants = getPlants();

  if (!filters) {
    return plants;
  }

  return filterPlants(plants, filters);
}

/**
 * Search plants by name (common or scientific)
 */
export function searchPlants(query: string): Plant[] {
  const lowerQuery = query.toLowerCase().trim();

  if (!lowerQuery) {
    return ALL_PLANTS;
  }

  return ALL_PLANTS.filter(plant => {
    const commonName = plant.commonName.toLowerCase();
    const scientificName = plant.scientificName.toLowerCase();

    return commonName.includes(lowerQuery) || scientificName.includes(lowerQuery);
  });
}

/**
 * Get plant statistics
 */
export function getPlantStats() {
  return {
    total: ALL_PLANTS.length,
    withImages: ALL_PLANTS.filter(p => p.imageUrl).length,
    withZones: ALL_PLANTS.filter(p => p.zoneMin && p.zoneMax).length,
    native: ALL_PLANTS.filter(p => p.isNative).length,
    pollinatorFriendly: ALL_PLANTS.filter(p => p.isPollinatorFriendly).length,
    beginnerFriendly: ALL_PLANTS.filter(p => p.beginnerFriendly).length,
    toxic: ALL_PLANTS.filter(p => p.toxicityToPets === 'toxic').length,
    nonToxic: ALL_PLANTS.filter(p => p.toxicityToPets === 'non-toxic').length,
    unknownToxicity: ALL_PLANTS.filter(p => p.toxicityToPets === 'unknown').length,
  };
}

/**
 * Get unique plant types from dataset
 */
export function getPlantTypes(): string[] {
  const types = new Set<string>();
  ALL_PLANTS.forEach(plant => {
    if (plant.plantType) {
      types.add(plant.plantType);
    }
  });
  return Array.from(types).sort();
}

/**
 * Get zone range covered by dataset
 */
export function getZoneRange(): { min: number; max: number } {
  let min = Infinity;
  let max = -Infinity;

  ALL_PLANTS.forEach(plant => {
    if (plant.zoneMin && plant.zoneMin < min) min = plant.zoneMin;
    if (plant.zoneMax && plant.zoneMax > max) max = plant.zoneMax;
  });

  return {
    min: min === Infinity ? 1 : min,
    max: max === -Infinity ? 13 : max
  };
}
